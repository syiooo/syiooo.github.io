æœ¬ç« ç»“æ„ï¼š

$$
çº¿æ€§è¡¨\begin{cases}
é¡ºåºå­˜å‚¨â€”â€”é¡ºåºè¡¨ \\
é“¾å¼å­˜å‚¨ \begin{cases}
å•é“¾è¡¨ï¼ˆæŒ‡é’ˆå®ç°ï¼‰ \\
åŒé“¾è¡¨ï¼ˆæŒ‡é’ˆå®ç°ï¼‰ \\
å¾ªç¯é“¾è¡¨ï¼ˆæŒ‡é’ˆå®ç°ï¼‰ \\
é™æ€é“¾è¡¨ï¼ˆå€ŸåŠ©æ•°ç»„å®ç°ï¼‰
\end{cases}
\end{cases}
$$


## 2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ

### 2.1.1 çº¿æ€§è¡¨çš„å®šä¹‰

å®šä¹‰ï¼šå…·æœ‰**ç›¸åŒæ•°æ®ç±»å‹**çš„ $n$ ä¸ªæ•°æ®å…ƒç´ çš„**æœ‰é™åºåˆ—**ã€‚
- $n$ ä¸ºè¡¨é•¿ï¼Œ$n\geq0$ã€‚$n=0$ æ—¶ä¸ºç©ºè¡¨ã€‚
- ç”¨ $L$ è¡¨ç¤ºä¸ºï¼š
	- $L=(a_{1},a_{2},\dots,a_{i},a_{i+1},\dots,a_{n})$
	- $a_{1}$ï¼šç¬¬ä¸€ä¸ªæ•°æ®å…ƒç´ ï¼Œä¹Ÿå«**è¡¨å¤´å…ƒç´ **ã€‚
	- $a_{n}$ï¼šæœ€åä¸€ä¸ªæ•°æ®å…ƒç´ ï¼Œä¹Ÿå«**è¡¨å°¾å…ƒç´ **ã€‚
- é€»è¾‘ç‰¹æ€§ï¼š
	- é™¤ç¬¬ä¸€ä¸ªå…ƒç´ å¤–ï¼Œæ¯ä¸ªå…ƒç´ æœ‰ä¸”ä»…æœ‰**ä¸€ä¸ªç›´æ¥å‰é©±**ã€‚
	- é™¤æœ€åä¸€ä¸ªå…ƒç´ å¤–ï¼Œæ¯ä¸ªå…ƒç´ æœ‰ä¸”ä»…æœ‰**ä¸€ä¸ªç›´æ¥åç»§**ã€‚
- ç‰¹ç‚¹ï¼š
	- è¡¨ä¸­å…ƒç´ çš„**ä¸ªæ•°æœ‰é™**ã€‚
	- è¡¨ä¸­å…ƒç´ å…·æœ‰é€»è¾‘ä¸Šé¡ºåºæ€§ï¼Œè¡¨ä¸­**å…ƒç´ æœ‰å…ˆåæ¬¡åº**ã€‚
	- è¡¨ä¸­éƒ½æ˜¯æ•°æ®å…ƒç´ ï¼Œæ¯ä¸ª**å…ƒç´ éƒ½æ˜¯å•ä¸ªå…ƒç´ **ã€‚
	- è¡¨ä¸­**å…ƒç´ çš„æ•°æ®ç±»å‹éƒ½ç›¸åŒ**ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªå…ƒç´ æ‰€å æ®çš„å­˜å‚¨ç©ºé—´ç›¸åŒã€‚
	- è¡¨ä¸­å…ƒç´ å…·æœ‰æŠ½è±¡æ€§ï¼Œ**åªè®¨è®ºå…ƒç´ ä¹‹é—´çš„é€»è¾‘å…³ç³»**ï¼Œä¸å…³å¿ƒå…ƒç´ å†…å®¹ã€‚

> æ³¨æ„åŒºåˆ†**é¡ºåºè¡¨**å’Œ**çº¿æ€§è¡¨**ï¼Œçº¿æ€§è¡¨æ˜¯ä¸€ç§é«˜åº¦æŠ½è±¡çš„**é€»è¾‘ç»“æ„**ï¼Œè€Œé¡ºåºè¡¨æ˜¯**å­˜å‚¨ç»“æ„**ã€‚é¡ºåºè¡¨å’Œé“¾è¡¨åœ¨åŒä¸€å±‚æ¬¡ã€‚
### 2.1.2 çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œ

åŸºæœ¬æ“ä½œï¼šæŒ‡ä¸€ä¸ªæ•°æ®ç»“æ„**æœ€æ ¸å¿ƒã€æœ€åŸºæœ¬**çš„æ“ä½œã€‚
å…¶ä»–å¤æ‚æ“ä½œï¼šå¯è°ƒç”¨åŸºæœ¬æ“ä½œæ¥å®ç°ã€‚

çº¿æ€§è¡¨çš„ä¸»è¦æ“ä½œæœ‰ï¼š
- `InitList(&L)`ï¼šåˆå§‹åŒ–è¡¨ã€‚
	- æ„é€ ä¸€ä¸ªç©ºçº¿æ€§è¡¨ã€‚
- `Length(L)`ï¼šæ±‚è¡¨é•¿ã€‚
	- è¿”å›çº¿æ€§è¡¨çš„é•¿åº¦ $L$ï¼Œå³è¡¨ä¸­çš„æ•°æ®ä¸ªæ•°ã€‚
- `LocateElem(L, e)`ï¼šæŒ‰å€¼æŸ¥æ‰¾æ“ä½œã€‚
	- åœ¨è¡¨ $L$ ä¸­æŸ¥æ‰¾å…·æœ‰ç»™å®šå…³é”®å­—å€¼çš„å…ƒç´ ã€‚
- `GetElem(L, i)`ï¼šæŒ‰ä½æŸ¥æ‰¾æ“ä½œã€‚
	- æŒ‰ä½æŸ¥æ‰¾æ“ä½œã€‚è·å–è¡¨ $L$ ä¸­ç¬¬ $i$ ä¸ªä½ç½®çš„å…ƒç´ çš„å€¼ã€‚
- `ListInsert(&L, i, e)`ï¼šæ’å…¥æ“ä½œã€‚
	- åœ¨è¡¨ $L$ ä¸­çš„ç¬¬ $i$ ä¸ªä½ç½®ä¸Šæ’å…¥æŒ‡å®šå…ƒç´  $e$ã€‚
- `ListDelete(&L, i, &e)`ï¼šåˆ é™¤æ“ä½œã€‚
	- åˆ é™¤è¡¨ $L$ ä¸­ç¬¬ $i$ ä¸ªä½ç½®çš„å…ƒç´ ï¼Œå¹¶ç”¨ $e$ è¿”å›åˆ é™¤å…ƒç´ çš„å€¼ã€‚
- `PrintList(L)`ï¼šè¾“å‡ºæ“ä½œã€‚
	- æŒ‰å‰åé¡ºåºè¾“å‡ºçº¿æ€§è¡¨ $L$ ä¸­çš„æ‰€æœ‰å…ƒç´ çš„å€¼ã€‚
- `Empty(L)`ï¼šåˆ¤ç©ºæ“ä½œã€‚
	- è‹¥ $L$ ä¸ºç©ºè¡¨è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
- `DestroyList(&L)`ï¼šé”€æ¯æ“ä½œã€‚
	- é”€æ¯çº¿æ€§è¡¨ï¼Œé‡Šæ”¾çº¿æ€§è¡¨ $L$ æ‰€å ç”¨çš„å†…å­˜ç©ºé—´ã€‚

> 1ï¸âƒ£åŸºæœ¬æ“ä½œçš„å®ç°å–å†³äºå­˜å‚¨ç»“æ„ï¼Œå­˜å‚¨ç»“æ„ä¸åŒç®—æ³•å®ç°ä¹Ÿä¸åŒã€‚2ï¸âƒ£ `&` ä¸º C++ä¸­çš„å¼•ç”¨è°ƒç”¨ã€‚

## 2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º

> ä»å­—é¢ä¸Šå°±èƒ½ç†è§£ï¼Œé¡ºåºè¡¨æ˜¯æœ‰é¡ºåºçš„çº¿æ€§è¡¨ï¼Œçº¦æŸæ¡ä»¶æ›´å¼ºã€‚

é¡ºåºè¡¨ï¼šçº¿æ€§è¡¨çš„**é¡ºåºå­˜å‚¨**ã€‚
ç‰¹ç‚¹ï¼š
- ç”¨**åœ°å€è¿ç»­çš„å­˜å‚¨**å•å…ƒä¾æ¬¡å­˜å‚¨çº¿æ€§è¡¨ä¸­çš„æ•°æ®å…ƒç´ ã€‚
- **é€»è¾‘ç›¸é‚»**çš„ä¸¤ä¸ªå…ƒç´ åœ¨**ç‰©ç†ä½ç½®ä¸Šä¹Ÿç›¸é‚»**ã€‚
- é€»è¾‘é¡ºåºä¸ç‰©ç†é¡ºåºä¿æŒä¸€è‡´ã€‚
- ç‰©ç†å­˜å‚¨ä½ç½®ä¸ä½åºæˆæ­£æ¯”ï¼Œæ•…å¯ä»¥å®ç°éšæœºå­˜å–ã€‚

ä¼˜ç‚¹ï¼š
- éšæœºè®¿é—®ï¼Œé€šè¿‡é¦–åœ°å€+å…ƒç´ åºå· $O(1)$ æ—¶é—´å†…æ‰¾åˆ°æŒ‡å®šå…ƒç´ ã€‚
- å…ƒç´ å¯†åº¦é«˜ã€‚

ç¼ºç‚¹ï¼š
- æ’å…¥å’Œåˆ é™¤è€—æ—¶ï¼Œå¯èƒ½éœ€è¦ç§»åŠ¨å¤§é‡å…ƒç´ ã€‚
- éœ€è¦è¿ç»­ç©ºé—´æ‰èƒ½å­˜å‚¨ï¼Œä¸å¤Ÿçµæ´»ã€‚

> éšæœºå­˜å–å°±æ˜¯ä¸éœ€è¦éå†çº¿æ€§è¡¨ï¼Œç›´æ¥ç»™å‡ºä¸€ä¸ªä½åºå°±å¯ä»¥ç›´æ¥å­˜å…¥ã€‚

ä½åºï¼šç§° $i$ ä¸ºå…ƒç´  $a_{i}$ åœ¨é¡ºåºè¡¨ä¸­çš„ä½åºã€‚

> é¡ºåºè¡¨ä¸­å…ƒç´ çš„ä½åºä» `1` å¼€å§‹ï¼Œè€Œæ•°ç»„çš„ä¸‹æ ‡æ˜¯ä» `0` å¼€å§‹çš„ã€‚


**é™æ€åˆ†é…**é¡ºåºè¡¨çš„å­˜å‚¨ç»“æ„æè¿°ï¼š
```c
#define MaxSize 50                // å®šä¹‰çº¿æ€§è¡¨æœ€å¤§é•¿åº¦
typedef struct {              
    ElemType data[MaxSize];       // é¡ºåºè¡¨çš„å…ƒç´ 
    int length;                   // é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
}SqList;                          // é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰

// Cè¯­è¨€ä¸­åˆ†é…è¯­å¥ä¸º
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```

**åŠ¨æ€åˆ†é…**é¡ºåºè¡¨çš„å­˜å‚¨ç»“æ„æè¿°ï¼š
```c
#define MaxSize 100                   // è¡¨é•¿åº¦åˆå§‹å®šä¹‰
typedef struct {              
    ElemType *data;                   // ç”¨æ¥åŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
    int MaxSize,length;               // æ•°ç»„æœ€å¤§å®¹é‡å’Œå½“å‰ä¸ªæ•°
}SqList;                              // åŠ¨æ€åˆ†é…æ•°ç»„é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰

// C++ä¸­åŠ¨æ€åˆ†é…è¯­å¥ä¸º
L.data = new ElemType[InitSize];
```

??? info "typedef"

	ç”¨æ³•ç±»ä¼¼äºå®šä¹‰ä¸€ä¸ªç±»ã€‚
	
	```c
	#include <stdio.h>
	#include <string.h>
	 
	typedef struct Books
	{
	   char  title[50];
	   char  author[50];
	   char  subject[100];
	   int   book_id;
	} Book;
	 
	int main( )
	{
	   Book book;
	 
	   strcpy( book.title, "C æ•™ç¨‹");
	   strcpy( book.author, "Runoob"); 
	   strcpy( book.subject, "ç¼–ç¨‹è¯­è¨€");
	   book.book_id = 12345;
	 
	   printf( "ä¹¦æ ‡é¢˜ : %s\n", book.title);
	   printf( "ä¹¦ä½œè€… : %s\n", book.author);
	   printf( "ä¹¦ç±»ç›® : %s\n", book.subject);
	   printf( "ä¹¦ ID : %d\n", book.book_id);
	 
	   return 0;
	}
	```

## 2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º

### 2.3.1 é¡ºåºè¡¨çš„åˆå§‹åŒ–

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// é™æ€åˆ†é…å¤§å°
#define MaxSize 50
// åŠ¨æ€åˆ†é…å¤§å°
#define InitSize 100
#define ElemType int

typedef enum {false, true} bool;

#define bool int


// é™æ€åˆ†é…å®šä¹‰
typedef struct
{
  ElemType data[MaxSize];
  ElemType length;
} SeqList;

// åŠ¨æ€åˆ†é…å®šä¹‰
typedef struct
{
  ElemType *data;
  ElemType MaxSizeDynamic, length;
} SeqListDynamic;

// é™æ€åˆå§‹åŒ–ä¸€ä¸ªé¡ºåºè¡¨
void InitList(SeqList *L)
{
  L->length = 0; // åˆå§‹åŒ–é¡ºåºé•¿åº¦ä¸º 0
}

// åŠ¨æ€åˆå§‹åŒ–ä¸€ä¸ªé¡ºåºè¡¨
void InitListDynamic(SeqListDynamic *L)
{
  L->data = (ElemType *)malloc(InitSize * sizeof(ElemType)); // åˆ†é…å­˜å‚¨ç©ºé—´
  L->length = 0;
  L->MaxSizeDynamic = InitSize;
}

// æ’å…¥æ“ä½œ
bool ListInsert(SeqList *L, int i, ElemType e) {
  if (i <)
  return true;
}

int main()
{
  SeqList seq;
  InitList(&seq);
  // é™æ€é¡ºåºè¡¨
  printf("=========== è¾“å‡ºé™æ€é¡ºåºè¡¨åˆå§‹åŒ–ç»“æœ ===========\n");
  printf(">> é•¿åº¦ï¼š%d\n", seq.length);
  printf(">> æ•°æ®data[0]ï¼š%d", seq.data[0]);
  puts("\n");

  // åŠ¨æ€é¡ºåºè¡¨
  printf("=========== è¾“å‡ºåŠ¨æ€é¡ºåºè¡¨åˆå§‹åŒ–ç»“æœ ===========\n");
  SeqListDynamic seqDynamic;
  InitListDynamic(&seqDynamic);
  printf(">> é•¿åº¦ï¼š%d\n", seqDynamic.length);
  printf(">> é•¿åº¦ä¸Šé™ï¼š%d\n", seqDynamic.MaxSizeDynamic);
  printf(">> æ•°æ®data[0]ï¼š%d", seq.data[0]);
  return 0;
}
```

è¿™æ˜¯æ ¹æ® wd ä¹¦å†™çš„ä¸€æ®µé¡ºåºè¡¨çš„åˆå§‹åŒ– C è¯­è¨€ä»£ç ã€‚

> è¦ç‚¹åœ¨äº `malloc()` å‡½æ•°çš„ä½¿ç”¨æ–¹æ³•ï¼Œä¸ºäº†ä½¿ç”¨ `malloc()` åˆ«å¿˜äº†å¼•å…¥ `stdlib.h`ã€‚
### 2.3.2 é¡ºåºè¡¨çš„æ’å…¥æ“ä½œ

è¿™é‡Œæˆ‘æ€è€ƒäº†ä¸€ä¸ªä»é«˜ä¸­å¼€å§‹å°±æ€è€ƒè¿‡çš„ä¸€ä¸ªé—®é¢˜ï¼š

> [!QUESTION] ç–‘é—®ğŸ¤”
> åœ¨å­¦ä¹ æ•°æ®ç»“æ„æ—¶ï¼Œæ€»æ˜¯åœ¨æ•°ç»„ä¸‹æ ‡å’Œä½åºä¹‹é—´åˆ‡æ¢ï¼Œæˆ‘æ„Ÿè§‰å¾ˆéš¾å—ï¼Œè€æ˜¯éœ€è¦åœ¨å¤„ç†è¾¹ç•Œæ¡ä»¶ä¸ŠèŠ±å¾ˆä¹…çš„æ—¶é—´ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆå¥½çš„ç›´è§‚çš„æ–¹æ³•å¸®æˆ‘è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä»è€Œåœ¨æ¯æ¬¡æ€è€ƒè¿™ç§è¾¹ç•Œå¤„ç†æ—¶æ›´å¿«ï¼Ÿ
> 

> [!Success] ç­”ï¼š
> è„‘ä¸­ä¸€å¥—ä½“ç³»ï¼Œæ‰‹ä¸Šä¸€æ¬¡å¹³ç§»ï¼›è¾¹ç•Œç”»æˆæ ¼ï¼Œé€»è¾‘è‡ªç„¶é½ã€‚
> **æ–¹æ³•ä¸€**ï¼šç®—æ³•é€»è¾‘ç»Ÿä¸€ç”¨ 0-based
> **æ–¹æ³•äºŒ(Recommend)**ï¼šç®—æ³•é€»è¾‘å…¨ç”¨ 1-based æ€è€ƒï¼Œå†™ä»£ç æ—¶å†å¯¹æ‰€æœ‰ä¸‹æ ‡æ•´ä½“å¹³ç§»ï¼Œç±»ä¼¼äº   `#define` çš„é‚£ç§å‘³é“ã€‚
> å¯¹äºè¾¹ç•Œé—®é¢˜ï¼Œæ•°æ ¼å­ä¸æ•°ç‚¹ã€‚

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// é™æ€åˆ†é…å¤§å°
#define MaxSize 50
// çº¿æ€§è¡¨å…ƒç´ ç±»å‹
#define ElemType int

typedef enum {false, true} bool;

#define bool int


// é™æ€åˆ†é…å®šä¹‰
typedef struct
{
  ElemType data[MaxSize];
  ElemType length;
} SeqList;

// é™æ€åˆå§‹åŒ–ä¸€ä¸ªé¡ºåºè¡¨
void InitList(SeqList *L)
{
  L->length = 0; // åˆå§‹åŒ–é¡ºåºé•¿åº¦ä¸º 0
}

// æ’å…¥æ“ä½œï¼ˆè¿™é‡Œä¸ºé‡‡ç”¨é™æ€å®šä¹‰çš„çº¿æ€§è¡¨ï¼‰
bool ListInsert(SeqList *L, int i, ElemType e) {
  printf("Insert value: %d\n", e);
  if (i < 1 || i > L->length+1) {
    printf("Insert Error: Invalid position!\n");
    return false; // æ’å…¥åˆ°æ— æ•ˆçš„ä½ç½®
} else if (L->length >= MaxSize) {
    printf("Insert Error: Space full!\n");
    return false; // å·²ç»å°†åˆ†é…çš„ç©ºé—´ç”¨å°½
  } else {
    for (int j = L->length; j >= i; j --) {
      L->data[j] = L->data[j-1];
    }
    L->data[i-1] = e;
    printf("Insert Successful!\n\n");
    L->length++;
    return true;
  }
  return false;
}

void logList(SeqList *p) {
  printf("[ ");
  for (int i = 0; i < p->length - 1; i ++ ) {
    // é»˜è®¤è®¤ä¸ºæ˜¯ int ç±»å‹ï¼Œå¹¶æ ¼å¼åŒ–è¾“å‡ºã€‚
    printf("%d ", p->data[i]);
  }
  puts("]");
}

int main()
{
  SeqList seq;
  InitList(&seq);
  // é™æ€é¡ºåºè¡¨
  printf("=========== è¾“å‡ºé™æ€é¡ºåºè¡¨åˆå§‹åŒ–ç»“æœ ===========\n");
  printf(">> é•¿åº¦ï¼š%d\n", seq.length);
  printf(">> æ•°æ®data[0]ï¼š%d\n", seq.data[0]);
  ListInsert(&seq, 1, 33);
  ListInsert(&seq, 2, 128);
  ListInsert(&seq, 3, 999);
  ListInsert(&seq, 4, 190);
  logList(&seq);
  puts("You've successfully insert some values~\n");
  return 0;
}
```

### 2.3.3 é¡ºåºè¡¨çš„åˆ é™¤æ“ä½œ

### 2.3.4 é¡ºåºè¡¨çš„æŒ‰å€¼æŸ¥æ‰¾

